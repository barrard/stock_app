{"version":3,"file":"static/webpack/static/development/pages/chart.js.72f34c9d41ba82da37a3.hot-update.js","sources":["webpack:///./components/charts/Canvas_Chart.js"],"sourcesContent":["import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport { connect } from \"react-redux\";\nimport { toastr } from \"react-redux-toastr\";\nimport { withRouter } from \"next/router\";\nimport { load_more_MA_results } from \"../../redux/actions/MA_analysis_actions\";\n\nclass Canvas_Chart extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      canvas_width: null,\n      canvas_height: null,\n      chart_height:'',\n      vol_canvas_height:'',\n      canvas: \"\",\n      context: {},\n      candle_width: 3,\n      space_between_bars: 0.5,\n      x_offset: 0,\n      data_loaded: false,\n      crosshair_overlay: \"\",\n      volume_canvas: \"\",\n      volume_canvas_overlay: \"\",\n      vol_canvas_share:0.1,\n\n      symbol: \"\",\n      spinner_timmer: \"\",\n      MA_data: {}\n    };\n    // this.draw_chart = this.draw_chart.bind(this)\n  }\n  componentDidMount() {\n    console.log(\"canvas mounted\");\n    this.make_canvas_full_screen();\n  }\n  componentDidUpdate(prevProps) {\n    console.log(\"componentDidUpdate\");\n    console.log(prevProps);\n    if (!prevProps.meta.is_loading && this.props.meta.is_loading) {\n      this.run_spinner();\n    }\n  }\n  make_canvas_full_screen() {\n    if (typeof window !== \"undefined\") {\n      let dom_node = ReactDOM.findDOMNode(this);\n      let { canvas_id } = this.props;\n      let canvas_width = dom_node.parentElement.clientWidth * 0.95;\n      let canvas_height = dom_node.parentElement.clientHeight;\n      this.setState({ canvas_width, canvas_height });\n      setTimeout(() => {\n        let canvas = document.getElementById(this.props.canvas_id);\n        this.run_spinner(canvas);\n        this.setState({ canvas });\n        console.log(\"does this run?\");\n        console.log(this);\n      }, 0);\n    }\n  }\n  run_spinner() {\n    var canvas = document.getElementById(this.props.canvas_id);\n    var context = canvas.getContext(\"2d\");\n    var start = new Date();\n    var lines = 16,\n      cW = context.canvas.width,\n      cH = context.canvas.height;\n\n    var draw_spinner = () => {\n      // console.log(this.props)\n      if (!this.props.meta.is_loading) {\n        clearInterval(this.state.spinner_timmer);\n        console.log(this.props.stock_data);\n        console.log(this.props.canvas_id);\n        console.log(this.props.stock_data.charts[this.props.canvas_id]);\n        let chart_data = this.props.stock_data.charts[this.props.canvas_id]\n          .chart_data;\n        console.log({ chart_data });\n        let MA_data = add_MA_data_to_model(chart_data);\n        console.log(MA_data);\n        this.setState({ MA_data });\n        return this.draw_chart(\"black\");\n      }\n      var rotation = parseInt(((new Date() - start) / 1000) * lines) / lines;\n      context.save();\n      context.clearRect(0, 0, cW, cH);\n      context.translate(cW / 2, cH / 2);\n      context.rotate(Math.PI * 2 * rotation);\n      for (var i = 0; i < lines; i++) {\n        context.beginPath();\n        context.rotate((Math.PI * 2) / lines);\n        context.moveTo(cW / 10, 0);\n        context.lineTo(cW / 4, 0);\n        context.lineWidth = cW / 30;\n        context.strokeStyle = \"rgba(0, 0, 0,\" + i / lines + \")\";\n        context.stroke();\n      }\n      context.restore();\n    };\n    let spinner_timmer = setInterval(draw_spinner, 1000 / 30);\n    this.setState({ spinner_timmer });\n  }\n  render_canvas(canvas_id, canvas_width, canvas_height) {\n    return (\n      <canvas\n        className=\"chart_canvas\"\n        id={canvas_id}\n        width={canvas_width}\n        height={canvas_height}\n      />\n    );\n  }\n  draw_chart(canvas_background_color) {\n    const { chart_data } = this.props.data;\n    const { canvas, vol_canvas_share, candle_width, space_between_bars } = this.state;\n\n    console.log(\"DRAW CART\");\n    let context = canvas.getContext(\"2d\", false);\n    clear_canvas(context, canvas_background_color);\n\n    /* get min and max values */\n    let min_price = this.get_min_price(chart_data);\n    let max_price = this.get_max_price(chart_data);\n    let max_vol = this.get_max_vol(chart_data);\n    console.log({ min_price, max_price, max_vol });\n\n    /* price / Time markers */\n    let date_marker_position = Math.floor(chart_data.length / 10);\n    console.log({ date_marker_position });\n    console.log(chart_data.length % date_marker_position);\n\n    console.log(`chart_data length ${chart_data.length}`);\n    console.log(`Candle width = ${candle_width}`);\n    const volume_canvas_height = canvas.height * vol_canvas_share; //volume will be lower 20% (should be adjustable)\n    const chart_height = canvas.height*(1-vol_canvas_share)\n    let number_of_pennies = (max_price - min_price) * 100;\n    let pennies_per_pixel = number_of_pennies / chart_height;\n    let pixels_per_penny = (chart_height) / number_of_pennies;\n    let pixels_per_vol = volume_canvas_height / max_vol;\n\n    console.log({\n      number_of_pennies,\n      pennies_per_pixel,\n      pixels_per_penny,\n      pixels_per_vol\n    });\n    this.setState({\n      volume_canvas_height,\nchart_height,\n      min_price,\n      max_price,\n      max_vol,\n      number_of_pennies,\n      pennies_per_pixel,\n      pixels_per_penny,\n      pixels_per_vol\n    });\n\n    this.draw_price_markers(context, min_price, max_price);\n    let { MA_20, MA_50, MA_200 } = this.state.MA_data;\n    this.draw_MA(MA_20, \"green\", context);\n    this.draw_MA(MA_50, \"blue\", context);\n    this.draw_MA(MA_200, \"red\", context);\n\n    chart_data.forEach((data, count) => {\n      const candle_position = count * candle_width + space_between_bars * count;\n  \n      if (count % date_marker_position == 0)\n        this.draw_date_marker(\n          candle_position,\n          candle_width,\n          data,\n          canvas\n        );\n  \n      this.draw_candle(\n        context,\n        candle_position,\n        data,\n        candle_width,\n        pixels_per_penny,\n        pixels_per_vol\n      );\n    });\n\n\n  }\n  draw_date_marker(candle_position, candle_width, data, canvas) {\n    console.log(candle_position)\n    console.log(data)\n    // console.log(canvas)\n    let context = canvas.getContext(\"2d\");\n    let date_time = this.parsed_date_time(data.date, data.label);\nconsole.log(date_time)\n    context.beginPath();\n    context.moveTo(candle_position + candle_width / 2, 0);\n    context.lineTo(candle_position + candle_width / 2, canvas.height);\n    context.stroke();\n    // context.fillStyle = \"white\";\n    // context.font = \"bold 10px Arial\";\n    // let text = context.measureText(date_time)\n    // context.fillText(date_time, candle_position - (text.width/2), canvas.height);\n  }\n  draw_price_markers(context, min, max) {\n    let {chart_height} = this.state\n    let canvas = context.canvas;\n    let range = max - min;\n\n    let intervals = parseFloat(range / 5).toFixed(4);\n    let marker_count = 0;\n    context.strokeStyle = `rgb(222, 222, 222)`;\n\n    let price_marker_position = Math.floor(chart_height / 5);\n    // console.log(price_marker_position)\n    // console.log({number_of_pennies, price_marker_position, pixels_per_penny})\n    for (let x = 0; x < chart_height; x++) {\n      if (x % price_marker_position == 0) {\n        context.beginPath();\n        context.moveTo(0, chart_height - x);\n        context.lineTo(canvas.width, chart_height - x);\n        context.stroke();\n        let price_label = parseFloat(min + marker_count * intervals).toFixed(2);\n\n        let text = context.measureText(price_label);\n        write_label(\n          price_label,\n          \"red\",\n          10,\n          context,\n          canvas.width - text.width * 2,\n          chart_height - x\n        );\n        marker_count++;\n      }\n    }\n  }\n  draw_volume(\n    candle_position,\n    max_vol,\n    data,\n    candle_width,\n    ctx,\n    pixels_per_vol\n  ) {\n    let {canvas} = ctx\n    \n    console.log(canvas.height - data.volume)\n    console.log(canvas.height - data.volume)\n    console.log(canvas.height - data.volume)\n\n    // ctx.fillStyle = color;\n    ctx.fillRect(\n      candle_position,\n      canvas.height - (data.volume * pixels_per_vol),\n      candle_width,\n      data.volume * pixels_per_vol\n    );\n  }\n   parsed_date_time(date, label) {\n    // console.log(date, label)\n    let month_day = date.slice(-4);\n    let day = month_day.slice(-2);\n    let month = month_day.slice(0, 2);\n    let year = date.slice(0, 4);\n\n    // console.log({ year, month_day, month, day})\n    // console.log(date)\n    return `${month}/${day}/${year} - ${label}`;\n  }\n\n  get_min_price(data) {\n    console.log(data);\n    return data.reduce((min, p) => (p.low < min ? p.low : min), data[0].low);\n  }\n  get_max_price(data) {\n    return data.reduce((max, p) => (p.high > max ? p.high : max), data[0].high);\n  }\n  get_max_vol(data) {\n    return data.reduce(\n      (max, p) => (p.volume > max ? p.volume : max),\n      data[0].volume\n    );\n  }\n// draw_candle(1, 100, 0, {low:0, high:80, open:75, close:80})\ndraw_candle(\n  context,\n  candle_position,\n  candle_data,\n  candle_width,\n  pixels_per_penny,\n  pixels_per_vol\n) {\n  var {max_price, max_vol} = this.state;\n\n  // console.log({ pennies_per_pixel })\n  // console.log({ pixels_per_penny })\n\n  // const total_range_in_pennies = canvas.height*pennies_per_pixel\n  // console.log({total_range_in_pennies})\n  // console.log({ candle_data})\n  // console.log((min_max.max - candle_data.high) * 100 * pixels_per_penny)\n  // console.log((min_max.max - candle_data.low) * 100 * pixels_per_penny)\n  // console.log(candle_position + (candle_width / 2))\n  context.beginPath();\n  context.moveTo(\n    candle_position + candle_width / 2,\n    (max_price - candle_data.high) * 100 * pixels_per_penny\n  );\n  context.lineTo(\n    candle_position + candle_width / 2,\n    (max_price - candle_data.low) * 100 * pixels_per_penny\n  );\n  context.stroke();\n\n  //candle rect\n  var candle_height;\n  if (candle_data.open > candle_data.close) {\n    // console.log('red')\n    context.fillStyle = \"red\";\n    candle_height =\n      (candle_data.open - candle_data.close) * 100 * pixels_per_penny;\n  } else if (candle_data.open == candle_data.close) {\n    // console.log('black')\n    context.fillStyle = \"black\";\n    candle_height = 1;\n  } else {\n    // console.log('green')\n    context.fillStyle = \"green\";\n    candle_height =\n      (candle_data.close - candle_data.open) * 100 * pixels_per_penny;\n  }\n  this.draw_volume(\n    candle_position,\n    max_vol,\n    candle_data,\n    candle_width,\n    context,\n    pixels_per_vol\n  );\n\n  context.fillRect(\n    candle_position,\n    (max_price - candle_data.open) * 100 * pixels_per_penny,\n    candle_width,\n    candle_height\n  );\n  //open line\n  // context.moveTo((candle_position + (candle_width/2))-(candle_width/2), high - candle_data.open);\n  // context.lineTo((candle_position + (candle_width/2)) + (candle_width / 2), high - candle_data.open)\n  // context.stroke();\n\n  //closing line\n}\n\n  draw_MA(data, color, context) {\n    let { canvas } = context;\n\n    let {\n      candle_width,\n      space_between_bars,\n      min_price,\n      max_price,\n      number_of_pennies,\n      pennies_per_pixel,\n      pixels_per_penny,\n      pixels_per_vol,\n      x_offset\n    } = this.state;\n\n    let symbol = this.props.chart_id;\n\n    let width = canvas.width;\n    let candle_count = width / (candle_width + space_between_bars);\n    console.log({ candle_count });\n    let MA_data = data;\n    let data_length = MA_data.length;\n    let new_data;\n    if (x_offset == 0) {\n      new_data = MA_data.slice(candle_count * -1);\n    } else {\n      let end_of_data = data_length - x_offset - candle_count;\n      if (end_of_data < 0) end_of_data = 0;\n      if (x_offset + candle_count > data_length)\n        Main_data.canvas_data[0].x_offset = x_offset =\n          data_length - candle_count;\n\n      new_data = MA_data.slice(end_of_data, x_offset * -1);\n    }\n    context.strokeStyle = `${color}`;\n    new_data.forEach((d, count) => {\n      if (!new_data[count - 1]) return console.log(\"COUNT IS 0\");\n      const candle_position = count * candle_width + space_between_bars * count;\n      const prev_candle_position =\n        (count - 1) * candle_width + space_between_bars * (count - 1);\n      context.beginPath();\n      let move_to_x = prev_candle_position + candle_width / 2;\n\n      let move_to_y =\n        (max_price - new_data[count - 1].close) * 100 * pixels_per_penny;\n      context.moveTo(move_to_x, move_to_y);\n      let line_to_x = candle_position + candle_width / 2;\n      let line_to_y = (max_price - d.close) * 100 * pixels_per_penny;\n      context.lineTo(line_to_x, line_to_y);\n  \n      context.stroke();\n    });\n  }\n\n  render() {\n    let { canvas_width, canvas_height } = this.state;\n    let { canvas_id, chart_data, meta } = this.props;\n    let { is_loading } = meta;\n\n    return (\n      <>\n        <span>{is_loading && <p>Loading Data....</p>} </span>{\" \"}\n        {/* this is here to make it work, dont remove */}\n        {canvas_width &&\n          canvas_height &&\n          this.render_canvas(canvas_id, canvas_width, canvas_height)}\n      </>\n    );\n  }\n}\n\nfunction mapStateToProps(state) {\n  const { stock_data, meta } = state;\n  return { stock_data, meta };\n}\n\nexport default connect(mapStateToProps)(withRouter(Canvas_Chart));\n\nfunction clear_canvas(context, canvas_background_color) {\n  let cW = context.canvas.width,\n    cH = context.canvas.height;\n  context.clearRect(0, 0, cW, cH);\n  // context.fillStyle = canvas_background_color\n  // context.fillRect(0, 0, cW, cH);\n}\n\nfunction write_label(text, color, size, ctx, x, y) {\n  ctx.fillStyle = color;\n  ctx.font = `bold ${size}px Arial`;\n  let label = text;\n  var text = ctx.measureText(label);\n  ctx.fillText(label, x, y);\n}\n\nfunction add_MA_data_to_model(daily_data) {\n  let before_cal = new Date().getTime();\n  /* ensure we have data for the symbol*/\n  let MA_obj = {\n    MA_20: [],\n    MA_50: [],\n    MA_200: []\n  };\n\n  let length = daily_data.length;\n\n  let counter = -1;\n  let MA_20 = 20; //minumum MA to calculater, hard coded..\n  let MA_50 = 50; //minumum MA to calculater, hard coded..\n  let MA_200 = 200; //minumum MA to calculater, hard coded..\n  /* Start a loop */\n  while (counter < length - MA_20) {\n    counter++;\n    /* start from the begining of the array */\n    let end_counter_20 = MA_20 + counter;\n    let end_counter_50 = MA_50 + counter;\n    let end_counter_200 = MA_200 + counter;\n    /* get the number MA items in array */\n    /* 20 */\n    if (length >= MA_20) {\n      let slice_20 = slice_data(counter, end_counter_20, daily_data);\n      let price_MA_data = get_price_type_averages(slice_20);\n\n      MA_obj.MA_20[end_counter_20 - 1] = price_MA_data;\n    }\n    if (length >= end_counter_50) {\n      let slice_50 = slice_data(counter, end_counter_50, daily_data);\n      let price_MA_data = get_price_type_averages(slice_50);\n\n      MA_obj.MA_50[end_counter_50 - 1] = price_MA_data;\n    }\n    if (length >= end_counter_200) {\n      let slice_200 = slice_data(counter, end_counter_200, daily_data);\n      let price_MA_data = get_price_type_averages(slice_200);\n\n      MA_obj.MA_200[end_counter_200 - 1] = price_MA_data;\n    }\n  }\n\n  console.log(`done with `);\n  let after_cal = new Date().getTime();\n  console.log(after_cal - before_cal);\n  return MA_obj;\n}\n\n/* average all 4 price types */\nfunction get_price_type_averages(array_of_price_data) {\n  let length = array_of_price_data.length;\n  // let open = array_of_price_data.reduce((a, b) => a + b[\"open\"], 0);\n  let close = array_of_price_data.reduce((a, b) => a + b[\"close\"], 0);\n  // let high = array_of_price_data.reduce((a, b) => a + b[\"high\"], 0);\n  // let low = array_of_price_data.reduce((a, b) => a + b[\"low\"], 0);\n  let price_average_obj = {\n    // open: parseFloat((open / length).toFixed(2)),\n    close: parseFloat((close / length).toFixed(2))\n    // high: parseFloat((high / length).toFixed(2)),\n    // low: parseFloat((low / length).toFixed(2))\n  };\n  return price_average_obj;\n}\n\nfunction slice_data(start, end, array) {\n  return array.slice(start, end);\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AACA;AAAA;AACA;AADA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAlBA;AACA;AAHA;AAuBA;AACA;;;AAAA;AACA;AACA;AACA;;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AADA;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;;;AACA;AACA;AAEA;AACA;AACA;AACA;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;;;AACA;AAAA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAYA;AA9CA;AAAA;AAAA;AAAA;AAgDA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAOA;AAQA;AAGA;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;;;AAEA;AAMA;AAGA;AACA;AACA;AACA;AAEA;AAMA;;;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;;;AAEA;AACA;AACA;AAAA;AAAA;AACA;;;AACA;AACA;AAAA;AAAA;AACA;;;AACA;AACA;AACA;AAAA;AAGA;AACA;;;AAEA;AAMA;AAAA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AAIA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AASA;AAOA;AACA;AACA;AAEA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAeA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;;;;AA9ZA;AACA;AAgaA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAHA;AAMA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AALA;AAMA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}